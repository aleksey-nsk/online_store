package com.example.demo.repository;

import com.example.demo.entity.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

/**
 * <h2>JPA Criteria API</h2>
 *
 * <p>Примером <strong>программно создаваемых запросов</strong> может служить любой фильтр, который позволяет
 * фильтровать данные по нескольким полям. Например можно представить себе фильтр людей по: имени, месту работы,
 * адресу проживания, серии и номеру паспорта. Причём фильтроваться люди могут по любой комбинации этих полей,
 * например по адресу проживания и месту работы, или по имени и адресу проживания. В терминах JPQL и SQL выразить
 * такой запрос невозможно, потому что нет оператора «выбрать, у которых поле равно такому-то значению
 * или игнорировать условие, если значение не установлено».</p>
 *
 * <p>Вариантов реализации такого фильтра несколько:</p>
 * <p>1) можно сделать 16 различных запросов и в зависимости от того, какие значения фильтра установлены,
 * выбирать подходящий запрос. Но это плохое решение.</p>
 * <p>2) можно собирать запрос из составляющих, пользуясь тем, что запрос это строка. Недостатков у этого подхода
 * тоже много: абсолютно нечитаемый код запроса в итоге, высокая вероятность составить кривой запрос,
 * сложность поддержания генератора запроса в актуальном состоянии и т.д.</p>
 * <p>3) наконец третий и наиболее правильный вариант, это использование <strong>JPA Criteria API</strong>.</p>
 *
 * <p><strong>JPA Criteria API</strong> - это мощный механизм по генерации <strong>динамических</strong>
 * и типобезопасных (при использовании Metamodel) запросов, который напрямую поддерживается в Spring Data JPA.</p>
 * <p>
 * <br/>
 *
 * <h2>Spring Data JPA Specifications</h2>
 *
 * <p>Spring Data JPA определяет интерфейс <strong>Specification</strong> для создания таких
 * <strong>предикатов Criteria API</strong>, которые можно было бы использовать повторно.
 * Чтобы использовать <strong>Спецификацию</strong> с репозиториями, необходимо чтобы репозиторий
 * имел в списке предков интерфейс <strong>JpaSpecificationExecutor</strong>.</p>
 *
 * <p>Можно реализовывать интерфейс Specification явно, но чаще используются вспомогательные классы,
 * которые группируют различные реализации Specification и предоставляют удобные методы для обращения к ним.
 * Поскольку речь идёт о прямом использовании <strong>JPA Criteria API</strong>, сложность и гибкость
 * спецификаций может быть сколь угодно высокой.</p>
 */
@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {
}
